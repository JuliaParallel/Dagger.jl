<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Management · Dagger.jl</title><meta name="title" content="Data Management · Dagger.jl"/><meta property="og:title" content="Data Management · Dagger.jl"/><meta property="twitter:title" content="Data Management · Dagger.jl"/><meta name="description" content="Documentation for Dagger.jl."/><meta property="og:description" content="Documentation for Dagger.jl."/><meta property="twitter:description" content="Documentation for Dagger.jl."/><meta property="og:url" content="https://JuliaParallel.github.io/Dagger.jl/data-management/"/><meta property="twitter:url" content="https://JuliaParallel.github.io/Dagger.jl/data-management/"/><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/data-management/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dagger.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Use Cases</span><ul><li><a class="tocitem" href="../use-cases/parallel-nested-loops/">Parallel Nested Loops</a></li></ul></li><li><a class="tocitem" href="../task-spawning/">Task Spawning</a></li><li class="is-active"><a class="tocitem" href>Data Management</a><ul class="internal"><li><a class="tocitem" href="#Chunks"><span>Chunks</span></a></li><li><a class="tocitem" href="#Mutation"><span>Mutation</span></a></li><li><a class="tocitem" href="#Sharding"><span>Sharding</span></a></li></ul></li><li><a class="tocitem" href="../darray/">Distributed Arrays</a></li><li><a class="tocitem" href="../scopes/">Scopes</a></li><li><a class="tocitem" href="../processors/">Processors</a></li><li><a class="tocitem" href="../task-queues/">Task Queues</a></li><li><a class="tocitem" href="../datadeps/">Datadeps</a></li><li><a class="tocitem" href="../propagation/">Option Propagation</a></li><li><span class="tocitem">Logging and Visualization</span><ul><li><a class="tocitem" href="../logging/">Logging: Basics</a></li><li><a class="tocitem" href="../logging-visualization/">Logging: Visualization</a></li><li><a class="tocitem" href="../logging-advanced/">Logging: Advanced</a></li></ul></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="../scheduler-internals/">Scheduler Internals</a></li><li><span class="tocitem">Dagger API</span><ul><li><a class="tocitem" href="../api-dagger/types/">Types</a></li><li><a class="tocitem" href="../api-dagger/functions/">Functions and Macros</a></li></ul></li><li><span class="tocitem">TimespanLogging API</span><ul><li><a class="tocitem" href="../api-timespanlogging/types/">Types</a></li><li><a class="tocitem" href="../api-timespanlogging/functions/">Functions and Macros</a></li></ul></li><li><span class="tocitem">DaggerWebDash API</span><ul><li><a class="tocitem" href="../api-daggerwebdash/types/">Types</a></li><li><a class="tocitem" href="../api-daggerwebdash/functions/">Functions and Macros</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Data Management</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data Management</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaParallel/Dagger.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/data-management.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Management"><a class="docs-heading-anchor" href="#Data-Management">Data Management</a><a id="Data-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Management" title="Permalink"></a></h1><p>Dagger is not just a computing platform - it also has awareness of where each piece of data resides, and will move data between workers and perform conversions as necessary to satisfy the needs of your tasks.</p><h2 id="Chunks"><a class="docs-heading-anchor" href="#Chunks">Chunks</a><a id="Chunks-1"></a><a class="docs-heading-anchor-permalink" href="#Chunks" title="Permalink"></a></h2><p>Dagger often needs to move data between workers to allow a task to execute. To make this efficient when communicating potentially large units of data, Dagger uses a remote reference, called a <code>Chunk</code>, to refer to objects which may exist on another worker. <code>Chunk</code>s are backed by a distributed refcounting mechanism provided by MemPool.jl, which ensures that the referenced data is not garbage collected until all <code>Chunk</code>s referencing that object are GC&#39;d from all workers.</p><p>Conveniently, if you pass in a <code>Chunk</code> object as an input to a Dagger task, then the task&#39;s payload function will get executed with the value contained in the <code>Chunk</code>. The scheduler also understands <code>Chunk</code>s, and will try to schedule tasks close to where their <code>Chunk</code> inputs reside, to reduce communication overhead.</p><p><code>Chunk</code>s also have a cached type, a &quot;processor&quot;, and a &quot;scope&quot;, which are important for identifying the type of the object, where in memory (CPU RAM, GPU VRAM, etc.) the value resides, and where the value is allowed to be transferred and dereferenced. See <a href="../processors/#Processors">Processors</a> and <a href="../scopes/#Scopes">Scopes</a> for more details on how these properties can be used to control scheduling behavior around <code>Chunk</code>s.</p><h2 id="Mutation"><a class="docs-heading-anchor" href="#Mutation">Mutation</a><a id="Mutation-1"></a><a class="docs-heading-anchor-permalink" href="#Mutation" title="Permalink"></a></h2><p>Normally, Dagger tasks should be functional and &quot;pure&quot;: never mutating their inputs, always producing identical outputs for a given set of inputs, and never producing side effects which might affect future program behavior. However, for certain codes, this restriction ends up costing the user performance and engineering time to work around.</p><p>Thankfully, Dagger provides the <code>Dagger.@mutable</code> macro for just this purpose. <code>@mutable</code> allows data to be marked such that it will never be copied or serialized by the scheduler (unless copied by the user). When used as an argument to a task, the task will be forced to execute on the same worker that <code>@mutable</code> was called on. For example:</p><pre><code class="language-julia hljs">Dagger.@mutable worker=2 Threads.Atomic{Int}(0)
x::Dagger.Chunk # The result is always a `Chunk`

# x is now considered mutable, and may only be accessed on worker 2:
wait(Dagger.@spawn Threads.atomic_add!(x, 1)) # Always executed on worker 2
wait(Dagger.@spawn scope=Dagger.scope(worker=1) Threads.atomic_add!(x, 1)) # SchedulingException</code></pre><p><code>@mutable</code>, when called as above, is constructed on worker 2, and the data gains a scope of <code>ProcessScope(myid())</code>, which means that any processor on that worker is allowed to execute tasks that use the object (subject to the usual scheduling rules).</p><p><code>@mutable</code> also allows the scope to be manually supplied, if more specific restrictions are desirable:</p><pre><code class="language-julia hljs">x = @mutable scope=Dagger.scope(worker=1, threads=[3,4]) rand(100)
# x is now scoped to threads 3 and 4 on worker `myid()`</code></pre><h2 id="Sharding"><a class="docs-heading-anchor" href="#Sharding">Sharding</a><a id="Sharding-1"></a><a class="docs-heading-anchor-permalink" href="#Sharding" title="Permalink"></a></h2><p><code>@mutable</code> is convenient for creating a single mutable object, but often one wants to have multiple mutable objects, with each object being scoped to their own worker or thread in the cluster, to be used as local counters, partial reduction containers, data caches, etc.</p><p>The <code>Shard</code> object (constructed with <code>Dagger.@shard</code>/<code>Dagger.shard</code>) is a mechanism by which such a setup can be created with one invocation.  By default, each worker will have their own local object which will be used when a task that uses the shard as an argument is scheduled on that worker. Other shard pieces that aren&#39;t scoped to the processor being executed on will not be serialized or copied, keeping communication costs constant even with a very large shard.</p><p>This mechanism makes it easy to construct a distributed set of mutable objects which are treated as &quot;mirrored shards&quot; by the scheduler, but require no further user input to access. For example, creating and using a local counter for each worker is trivial:</p><pre><code class="language-julia hljs"># Create a local atomic counter on each worker that Dagger knows about:
cs = Dagger.@shard Threads.Atomic{Int}(0)

# Let&#39;s add `1` to the local counter, not caring about which worker we&#39;re on:
wait.([Dagger.@spawn Threads.atomic_add!(cs, 1) for i in 1:1000])

# And let&#39;s fetch the total sum of all counters:
@assert sum(map(ctr-&gt;fetch(ctr)[], cs)) == 1000</code></pre><p>Note that <code>map</code>, when used on a shard, will execute the provided function once per shard &quot;piece&quot;, and each result is considered immutable. <code>map</code> is an easy way to make a copy of each piece of the shard, to be later reduced, scanned, etc.</p><p>Further details about what arguments can be passed to <code>@shard</code>/<code>shard</code> can be found in <a href="../api-dagger/functions/#Data-Management-Functions">Data Management Functions</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../task-spawning/">« Task Spawning</a><a class="docs-footer-nextpage" href="../darray/">Distributed Arrays »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 1 April 2024 19:42">Monday 1 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
