<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Processors · Dagger.jl</title><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/processors/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Dagger.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Processors</a><ul class="internal"><li><a class="tocitem" href="#Hardware-capabilities,-topology,-and-data-locality"><span>Hardware capabilities, topology, and data locality</span></a></li><li><a class="tocitem" href="#Redundancy"><span>Redundancy</span></a></li><li><a class="tocitem" href="#Dynamic-worker-pools"><span>Dynamic worker pools</span></a></li></ul></li><li><a class="tocitem" href="../scheduler-internals/">Scheduler Internals</a></li><li><a class="tocitem" href="../logging/">Logging and Graphing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Processors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Processors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/processors.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Processors"><a class="docs-heading-anchor" href="#Processors">Processors</a><a id="Processors-1"></a><a class="docs-heading-anchor-permalink" href="#Processors" title="Permalink"></a></h1><p>Dagger contains a flexible mechanism to represent CPUs, GPUs, and other devices that the scheduler can place user work on. The indiviual devices that are capable of computing a user operation are called &quot;processors&quot;, and are subtypes of <code>Dagger.Processor</code>. Processors are automatically detected by Dagger at scheduler initialization, and placed in a hierarchy reflecting the physical (network-, link-, or memory-based) boundaries between processors in the hierarchy. The scheduler uses the information in this hierarchy to efficiently schedule and partition user operations.</p><h2 id="Hardware-capabilities,-topology,-and-data-locality"><a class="docs-heading-anchor" href="#Hardware-capabilities,-topology,-and-data-locality">Hardware capabilities, topology, and data locality</a><a id="Hardware-capabilities,-topology,-and-data-locality-1"></a><a class="docs-heading-anchor-permalink" href="#Hardware-capabilities,-topology,-and-data-locality" title="Permalink"></a></h2><p>The processor hierarchy is modeled as a multi-root tree, where each root is an <code>OSProc</code>, which represents a Julia OS process, and the &quot;children&quot; of the root or some other branch in the tree represent the processors which reside on the same logical server as the &quot;parent&quot; branch. All roots are connected to each other directly, in the common case. The processor hierarchy&#39;s topology is automatically detected and elaborated by callbacks in Dagger, which users may manipulate to add detection of extra processors.</p><p>Movement of data between any two processors is decomposable into a sequence of &quot;moves&quot; between a child and its parent, termed a &quot;generic path move&quot;. Movement of data may also take &quot;shortcuts&quot; between nodes in the tree which are not directly connected if enabled by libraries or the user, which may make use of IPC mechanisms to transfer data more directly and efficiently (such as Infiniband, GPU RDMA, NVLINK, etc.). All data is considered local to some processor, and may only be operated on by another processor by first doing an explicit move operation to that processor.</p><p>A move between a given pair of processors is implemented as a Julia function dispatching on the types of each processor, as well as the type of the data being moved. Users are permitted to define custom move functions to improve data movement efficiency, perform automatic value conversions, or even make use of special IPC facilities. Custom processors may also be defined by the user to represent a processor type which is not automatically detected by Dagger, such as novel GPUs, special OS process abstractions, FPGAs, etc.</p><h3 id="Future:-Network-Devices-and-Topology"><a class="docs-heading-anchor" href="#Future:-Network-Devices-and-Topology">Future: Network Devices and Topology</a><a id="Future:-Network-Devices-and-Topology-1"></a><a class="docs-heading-anchor-permalink" href="#Future:-Network-Devices-and-Topology" title="Permalink"></a></h3><p>In the future, users will be able to define network devices attached to a given processor, which provides a direct connection to a network device on another processor, and may be used to transfer data between said processors. Data movement rules will most likely be defined by a similar (or even identical) mechanism to the current processor move mechanism. The multi-root tree will be expanded to a graph to allow representing these network devices (as they may potentially span non-root nodes).</p><h2 id="Redundancy"><a class="docs-heading-anchor" href="#Redundancy">Redundancy</a><a id="Redundancy-1"></a><a class="docs-heading-anchor-permalink" href="#Redundancy" title="Permalink"></a></h2><h3 id="Fault-Tolerance"><a class="docs-heading-anchor" href="#Fault-Tolerance">Fault Tolerance</a><a id="Fault-Tolerance-1"></a><a class="docs-heading-anchor-permalink" href="#Fault-Tolerance" title="Permalink"></a></h3><p>Dagger has a single means for ensuring redundancy, which is currently called &quot;fault tolerance&quot;. Said redundancy is only targeted at a specific failure mode, namely the unexpected exit or &quot;killing&quot; of a worker process in the cluster. This failure mode often presents itself when running on a Linux and generating large memory allocations, where the Out Of Memory (OOM) killer process can kill user processes to free their allocated memory for the Linux kernel to use. The fault tolerance system mitigates the damage caused by the OOM killer performing its duties on one or more worker processes by detecting the fault as a process exit exception (generated by Julia), and then moving any &quot;lost&quot; work to other worker processes for re-computation.</p><h4 id="Future:-Multi-master,-Network-Failure-Correction,-etc."><a class="docs-heading-anchor" href="#Future:-Multi-master,-Network-Failure-Correction,-etc.">Future: Multi-master, Network Failure Correction, etc.</a><a id="Future:-Multi-master,-Network-Failure-Correction,-etc.-1"></a><a class="docs-heading-anchor-permalink" href="#Future:-Multi-master,-Network-Failure-Correction,-etc." title="Permalink"></a></h4><p>This single redundancy mechanism helps alleviate a common issue among HPC and scientific users, however it does little to help when, for example, the master node exits, or a network link goes down. Such failure modes require a more complicated detection and recovery process, including multiple master processes, a distributed and replicated database such as etcd, and checkpointing of the scheduler to ensure an efficient recovery. Such a system does not yet exist, but contributions for such a change are desired.</p><h2 id="Dynamic-worker-pools"><a class="docs-heading-anchor" href="#Dynamic-worker-pools">Dynamic worker pools</a><a id="Dynamic-worker-pools-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-worker-pools" title="Permalink"></a></h2><p>Dagger&#39;s default scheduler supports modifying the worker pool while the scheduler is running. This is done by modifying the <code>Processor</code>s of the <code>Context</code> supplied to the scheduler at initialization using <code>addprocs!(ctx, ps)</code> and <code>rmprocs(ctx, ps)</code> where <code>ps</code> can be <code>Processor</code>s or just process ids.</p><p>An example of when this is useful is in HPC environments where individual jobs to start up workers are queued so that not all workers are guaranteed to be available at the same time.</p><p>New workers will typically be assigned new tasks as soon as the scheduler sees them. Removed workers will finish all their assigned tasks but will not be assigned any new tasks. Note that this makes it difficult to determine when a worker is no longer in use by Dagger. Contributions to alleviate this uncertainty are welcome!</p><p>Example:</p><pre><code class="language-julia">using Distributed

ps1 = addprocs(2, exeflags=&quot;--project&quot;)
@everywhere using Distributed, Dagger

# Dummy task to wait for 0.5 seconds and then return the id of the worker
ts = delayed(vcat)((delayed(i -&gt; (sleep(0.5); myid()))(i) for i in 1:20)...)

ctx = Context()
# Scheduler is blocking, so we need a new task to add workers while it runs
job = @async collect(ctx, ts)

# Lets fire up some new workers
ps2 = addprocs(2, exeflags=&quot;--project&quot;)
@everywhere ps2 using Distributed, Dagger
# New workers are not available until we do this
addprocs!(ctx, ps2)

# Lets hope the job didn&#39;t complete before workers were added :)
@show fetch(job) |&gt; unique

# and cleanup after ourselves...
workers() |&gt; rmprocs</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../scheduler-internals/">Scheduler Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 23 October 2020 18:21">Friday 23 October 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
