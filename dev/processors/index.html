<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Processors · Dagger.jl</title><meta name="title" content="Processors · Dagger.jl"/><meta property="og:title" content="Processors · Dagger.jl"/><meta property="twitter:title" content="Processors · Dagger.jl"/><meta name="description" content="Documentation for Dagger.jl."/><meta property="og:description" content="Documentation for Dagger.jl."/><meta property="twitter:description" content="Documentation for Dagger.jl."/><meta property="og:url" content="https://JuliaParallel.github.io/Dagger.jl/processors/"/><meta property="twitter:url" content="https://JuliaParallel.github.io/Dagger.jl/processors/"/><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/processors/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Dagger.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dagger.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Use Cases</span><ul><li><a class="tocitem" href="../use-cases/parallel-nested-loops/">Parallel Nested Loops</a></li></ul></li><li><a class="tocitem" href="../task-spawning/">Task Spawning</a></li><li><a class="tocitem" href="../task-affinity/">Task Affinity</a></li><li><a class="tocitem" href="../data-management/">Data Management</a></li><li><a class="tocitem" href="../darray/">Distributed Arrays</a></li><li><a class="tocitem" href="../streaming/">Streaming Tasks</a></li><li><a class="tocitem" href="../scopes/">Scopes</a></li><li class="is-active"><a class="tocitem" href>Processors</a><ul class="internal"><li><a class="tocitem" href="#Hardware-capabilities,-topology,-and-data-locality"><span>Hardware capabilities, topology, and data locality</span></a></li><li><a class="tocitem" href="#Processor-Selection"><span>Processor Selection</span></a></li><li><a class="tocitem" href="#Resource-Control"><span>Resource Control</span></a></li><li><a class="tocitem" href="#Redundancy"><span>Redundancy</span></a></li><li><a class="tocitem" href="#Dynamic-worker-pools"><span>Dynamic worker pools</span></a></li></ul></li><li><a class="tocitem" href="../task-queues/">Task Queues</a></li><li><span class="tocitem">Datadeps</span><ul><li><a class="tocitem" href="../datadeps/">Basics</a></li><li><a class="tocitem" href="../stencils/">Stencils</a></li></ul></li><li><a class="tocitem" href="../gpu/">GPUs</a></li><li><a class="tocitem" href="../propagation/">Option Propagation</a></li><li><span class="tocitem">Logging and Visualization</span><ul><li><a class="tocitem" href="../logging/">Logging: Basics</a></li><li><a class="tocitem" href="../logging-visualization/">Logging: Visualization</a></li><li><a class="tocitem" href="../logging-advanced/">Logging: Advanced</a></li></ul></li><li><span class="tocitem">External Languages</span><ul><li><a class="tocitem" href="../external-languages/python/">Python</a></li></ul></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="../scheduler-internals/">Scheduler Internals</a></li><li><span class="tocitem">Dagger API</span><ul><li><a class="tocitem" href="../api-dagger/types/">Types</a></li><li><a class="tocitem" href="../api-dagger/functions/">Functions and Macros</a></li></ul></li><li><span class="tocitem">TimespanLogging API</span><ul><li><a class="tocitem" href="../api-timespanlogging/types/">Types</a></li><li><a class="tocitem" href="../api-timespanlogging/functions/">Functions and Macros</a></li></ul></li><li><span class="tocitem">DaggerWebDash API</span><ul><li><a class="tocitem" href="../api-daggerwebdash/types/">Types</a></li><li><a class="tocitem" href="../api-daggerwebdash/functions/">Functions and Macros</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Processors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Processors</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaParallel/Dagger.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/processors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Processors"><a class="docs-heading-anchor" href="#Processors">Processors</a><a id="Processors-1"></a><a class="docs-heading-anchor-permalink" href="#Processors" title="Permalink"></a></h1><p>Dagger contains a flexible mechanism to represent CPUs, GPUs, and other devices that the scheduler can place user work on. The individual devices that are capable of computing a user operation are called &quot;processors&quot;, and are subtypes of <code>Dagger.Processor</code>. Processors are automatically detected by Dagger at scheduler initialization, and placed in a hierarchy reflecting the physical (network-, link-, or memory-based) boundaries between processors in the hierarchy. The scheduler uses the information in this hierarchy to efficiently schedule and partition user operations.</p><p>Dagger&#39;s <code>Chunk</code> objects can have a processor associated with them that defines where the contained data &quot;resides&quot;. Each processor has a set of functions that define the mechanisms and rules by which the data can be transferred between similar or different kinds of processors, and will be called by Dagger&#39;s scheduler automatically when fetching function arguments (or the function itself) for computation on a given processor.</p><p>Setting the processor on a function argument is done by wrapping it in a <code>Chunk</code> with <code>Dagger.tochunk</code>:</p><pre><code class="language-julia hljs">a = 1
b = 2
# Let&#39;s say `b` &quot;resides&quot; on the second thread of the first worker:
b_chunk = Dagger.tochunk(b, Dagger.ThreadProc(1, 2))::Dagger.Chunk
c = Dagger.@spawn a + b_chunk
fetch(c) == 3</code></pre><p>It&#39;s also simple to set the processor of the function being passed; it will be automatically wrapped in a <code>Chunk</code> if necessary:</p><pre><code class="language-julia hljs"># `+` is treated as existing on the second thread of the first worker:
Dagger.@spawn processor=Dagger.ThreadProc(1, 2) a + b</code></pre><p>You can also tell Dagger about the processor type for the returned value of a task by making it a <code>Chunk</code>:</p><pre><code class="language-julia hljs">Dagger.spawn(a) do a
    c = a + 1
    return Dagger.tochunk(c, Dagger.ThreadProc(1, 2))
end</code></pre><p>Note that unless you know that your function, arguments, or return value are associated with a specific processor, you don&#39;t need to assign one to them. Dagger will treat them as being simple values with no processor association, and will serialize them to wherever they&#39;re used.</p><h2 id="Hardware-capabilities,-topology,-and-data-locality"><a class="docs-heading-anchor" href="#Hardware-capabilities,-topology,-and-data-locality">Hardware capabilities, topology, and data locality</a><a id="Hardware-capabilities,-topology,-and-data-locality-1"></a><a class="docs-heading-anchor-permalink" href="#Hardware-capabilities,-topology,-and-data-locality" title="Permalink"></a></h2><p>The processor hierarchy is modeled as a multi-root tree, where each root is an <code>OSProc</code>, which represents a Julia OS process, and the &quot;children&quot; of the root or some other branch in the tree represent the processors which reside on the same logical server as the &quot;parent&quot; branch. All roots are connected to each other directly, in the common case. The processor hierarchy&#39;s topology is automatically detected and elaborated by callbacks in Dagger, which users may manipulate to add detection of extra processors.</p><p>A move between a given pair of processors is implemented as a Julia function dispatching on the types of each processor, as well as the type of the data being moved. Users are permitted to define custom move functions to improve data movement efficiency, perform automatic value conversions, or even make use of special IPC facilities. Custom processors may also be defined by the user to represent a processor type which is not automatically detected by Dagger, such as novel GPUs, special OS process abstractions, FPGAs, etc.</p><p>Movement of data between any two processors A and B (from A to B), if not defined by the user, is decomposed into 3 moves: processor A to OSProc parent of A, OSProc parent of A to OSProc parent of B, and OSProc parent of B to processor B. This mechanism uses Julia&#39;s Serialization library to serialize and deserialize data, so data must be serializable for this mechanism to work properly.</p><h2 id="Processor-Selection"><a class="docs-heading-anchor" href="#Processor-Selection">Processor Selection</a><a id="Processor-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Processor-Selection" title="Permalink"></a></h2><p>By default, Dagger uses the CPU to process work, typically single-threaded per cluster node. However, Dagger allows access to a wider range of hardware and software acceleration techniques, such as multithreading and GPUs. These more advanced (but performant) accelerators are disabled by default, but can easily be enabled by using scopes (see <a href="../scopes/#Scopes">Scopes</a> for details).</p><h2 id="Resource-Control"><a class="docs-heading-anchor" href="#Resource-Control">Resource Control</a><a id="Resource-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Resource-Control" title="Permalink"></a></h2><p>Dagger assumes that a thunk executing on a processor, fully utilizes that processor at 100%. When this is not the case, you can tell Dagger as much with <code>options.procutil</code>:</p><pre><code class="language-julia hljs">procutil = Dict(
    Dagger.ThreadProc =&gt; 4.0, # utilizes 4 CPU threads fully
    DaggerGPU.CuArrayProc =&gt; 0.1 # utilizes 10% of a single CUDA GPU
)</code></pre><p>Dagger will use this information to execute only as many thunks on a given processor (or set of similar processors) as add up to less than or equal to <code>1.0</code> total utilization. If a thunk is scheduled onto a processor which the local worker deems as &quot;oversubscribed&quot;, it will not execute the thunk until sufficient resources become available by thunks completing execution.</p><h3 id="GPU-Processors"><a class="docs-heading-anchor" href="#GPU-Processors">GPU Processors</a><a id="GPU-Processors-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Processors" title="Permalink"></a></h3><p>The <a href="https://github.com/JuliaGPU/DaggerGPU.jl">DaggerGPU.jl</a> package can be imported to enable GPU acceleration for NVIDIA and AMD GPUs, when available. The processors provided by that package are not enabled by default, but may be enabled via custom scopes (<a href="../scopes/#Scopes">Scopes</a>).</p><h3 id="Future:-Network-Devices-and-Topology"><a class="docs-heading-anchor" href="#Future:-Network-Devices-and-Topology">Future: Network Devices and Topology</a><a id="Future:-Network-Devices-and-Topology-1"></a><a class="docs-heading-anchor-permalink" href="#Future:-Network-Devices-and-Topology" title="Permalink"></a></h3><p>In the future, users will be able to define network devices attached to a given processor, which provides a direct connection to a network device on another processor, and may be used to transfer data between said processors. Data movement rules will most likely be defined by a similar (or even identical) mechanism to the current processor move mechanism. The multi-root tree will be expanded to a graph to allow representing these network devices (as they may potentially span non-root nodes).</p><h2 id="Redundancy"><a class="docs-heading-anchor" href="#Redundancy">Redundancy</a><a id="Redundancy-1"></a><a class="docs-heading-anchor-permalink" href="#Redundancy" title="Permalink"></a></h2><h3 id="Fault-Tolerance"><a class="docs-heading-anchor" href="#Fault-Tolerance">Fault Tolerance</a><a id="Fault-Tolerance-1"></a><a class="docs-heading-anchor-permalink" href="#Fault-Tolerance" title="Permalink"></a></h3><p>Dagger has a single means for ensuring redundancy, which is currently called &quot;fault tolerance&quot;. Said redundancy is only targeted at a specific failure mode, namely the unexpected exit or &quot;killing&quot; of a worker process in the cluster. This failure mode often presents itself when running on a Linux and generating large memory allocations, where the Out Of Memory (OOM) killer process can kill user processes to free their allocated memory for the Linux kernel to use. The fault tolerance system mitigates the damage caused by the OOM killer performing its duties on one or more worker processes by detecting the fault as a process exit exception (generated by Julia), and then moving any &quot;lost&quot; work to other worker processes for re-computation.</p><h4 id="Future:-Multi-master,-Network-Failure-Correction,-etc."><a class="docs-heading-anchor" href="#Future:-Multi-master,-Network-Failure-Correction,-etc.">Future: Multi-master, Network Failure Correction, etc.</a><a id="Future:-Multi-master,-Network-Failure-Correction,-etc.-1"></a><a class="docs-heading-anchor-permalink" href="#Future:-Multi-master,-Network-Failure-Correction,-etc." title="Permalink"></a></h4><p>This single redundancy mechanism helps alleviate a common issue among HPC and scientific users, however it does little to help when, for example, the master node exits, or a network link goes down. Such failure modes require a more complicated detection and recovery process, including multiple master processes, a distributed and replicated database such as etcd, and checkpointing of the scheduler to ensure an efficient recovery. Such a system does not yet exist, but contributions for such a change are desired.</p><h2 id="Dynamic-worker-pools"><a class="docs-heading-anchor" href="#Dynamic-worker-pools">Dynamic worker pools</a><a id="Dynamic-worker-pools-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-worker-pools" title="Permalink"></a></h2><p>Dagger&#39;s default scheduler supports modifying the worker pool while the scheduler is running. This is done by modifying the <code>Processor</code>s of the <code>Context</code> supplied to the scheduler at initialization using <code>addprocs!(ctx, ps)</code> and <code>rmprocs(ctx, ps)</code> where <code>ps</code> can be <code>Processor</code>s or just process ids.</p><p>An example of when this is useful is in HPC environments where individual jobs to start up workers are queued so that not all workers are guaranteed to be available at the same time.</p><p>New workers will typically be assigned new tasks as soon as the scheduler sees them. Removed workers will finish all their assigned tasks but will not be assigned any new tasks. Note that this makes it difficult to determine when a worker is no longer in use by Dagger. Contributions to alleviate this uncertainty are welcome!</p><p>Example:</p><pre><code class="language-julia hljs">using Distributed

ps1 = addprocs(2, exeflags=&quot;--project&quot;)
@everywhere using Distributed, Dagger

# Dummy task to wait for 0.5 seconds and then return the id of the worker
ts = delayed(vcat)((delayed(i -&gt; (sleep(0.5); myid()))(i) for i in 1:20)...)

ctx = Context()
# Scheduler is blocking, so we need a new task to add workers while it runs
job = @async collect(ctx, ts)

# Lets fire up some new workers
ps2 = addprocs(2, exeflags=&quot;--project&quot;)
@everywhere ps2 using Distributed, Dagger
# New workers are not available until we do this
addprocs!(ctx, ps2)

# Lets hope the job didn&#39;t complete before workers were added :)
@show fetch(job) |&gt; unique

# and cleanup after ourselves...
workers() |&gt; rmprocs</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../scopes/">« Scopes</a><a class="docs-footer-nextpage" href="../task-queues/">Task Queues »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 9 October 2025 17:14">Thursday 9 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
