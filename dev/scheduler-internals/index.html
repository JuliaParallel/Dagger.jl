<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scheduler Internals · Dagger.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/scheduler-internals/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dagger.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../task-spawning/">Task Spawning</a></li><li><a class="tocitem" href="../data-management/">Data Management</a></li><li><a class="tocitem" href="../darray/">Distributed Arrays</a></li><li><a class="tocitem" href="../scopes/">Scopes</a></li><li><a class="tocitem" href="../processors/">Processors</a></li><li><a class="tocitem" href="../task-queues/">Task Queues</a></li><li><a class="tocitem" href="../propagation/">Option Propagation</a></li><li><a class="tocitem" href="../logging/">Logging and Graphing</a></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../scheduler-visualization/">Scheduler Visualization</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../dynamic/">Dynamic Scheduler Control</a></li><li class="is-active"><a class="tocitem" href>Scheduler Internals</a><ul class="internal"><li><a class="tocitem" href="#Core-vs.-Worker-Schedulers"><span>Core vs. Worker Schedulers</span></a></li><li><a class="tocitem" href="#Core:-Basics"><span>Core: Basics</span></a></li><li><a class="tocitem" href="#Core:-Initialization"><span>Core: Initialization</span></a></li><li><a class="tocitem" href="#Core:-Outer-Loop"><span>Core: Outer Loop</span></a></li><li><a class="tocitem" href="#Core:-Task-Scheduling"><span>Core: Task Scheduling</span></a></li><li><a class="tocitem" href="#Worker:-Task-Execution"><span>Worker: Task Execution</span></a></li><li><a class="tocitem" href="#Worker:-Workload-Balancing"><span>Worker: Workload Balancing</span></a></li><li><a class="tocitem" href="#Core:-Finishing"><span>Core: Finishing</span></a></li><li><a class="tocitem" href="#Core:-Shutdown"><span>Core: Shutdown</span></a></li></ul></li><li><span class="tocitem">Dagger API</span><ul><li><a class="tocitem" href="../api-dagger/types/">Types</a></li><li><a class="tocitem" href="../api-dagger/functions/">Functions and Macros</a></li></ul></li><li><span class="tocitem">TimespanLogging API</span><ul><li><a class="tocitem" href="../api-timespanlogging/types/">Types</a></li><li><a class="tocitem" href="../api-timespanlogging/functions/">Functions and Macros</a></li></ul></li><li><span class="tocitem">DaggerWebDash API</span><ul><li><a class="tocitem" href="../api-daggerwebdash/types/">Types</a></li><li><a class="tocitem" href="../api-daggerwebdash/functions/">Functions and Macros</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Scheduler Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Scheduler Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/scheduler-internals.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Scheduler-Internals"><a class="docs-heading-anchor" href="#Scheduler-Internals">Scheduler Internals</a><a id="Scheduler-Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduler-Internals" title="Permalink"></a></h1><p>Dagger&#39;s scheduler can be found primarily in the <code>Dagger.Sch</code> module. It performs a variety of functions to support tasks and data, and as such is a complex system. This documentation attempts to shed light on how the scheduler works internally (from a somewhat high level), with the hope that it will help users and contributors understand how to improve the scheduler or fix any bugs that may arise from it.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>Dagger&#39;s scheduler is evolving at a rapid pace, and is a complex mix of interacting parts. As such, this documentation may become out of date very quickly, and may not reflect the current state of the scheduler. Please feel free to file PRs to correct or improve this document, but also beware that the true functionality is defined in Dagger&#39;s source!</p></div></div><h2 id="Core-vs.-Worker-Schedulers"><a class="docs-heading-anchor" href="#Core-vs.-Worker-Schedulers">Core vs. Worker Schedulers</a><a id="Core-vs.-Worker-Schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Core-vs.-Worker-Schedulers" title="Permalink"></a></h2><p>Dagger&#39;s scheduler is really two kinds of entities: the &quot;core&quot; scheduler, and &quot;worker&quot; schedulers:</p><p>The core scheduler runs on worker 1, thread 1, and is the entrypoint to tasks which have been submitted. The core scheduler manages all task dependencies, notifies calls to <code>wait</code> and <code>fetch</code> of task completion, and generally performs initial task placement. The core scheduler has cached information about each worker and their processors, and uses that information (together with metrics about previous tasks and other aspects of the Dagger runtime) to generate a near-optimal just-in-time task schedule.</p><p>The worker schedulers each run as a set of tasks across all workers and all processors, and handles data movement and task execution. Once the core scheduler has scheduled and launched a task, it arrives at the worker scheduler for handling. The worker scheduler will pass the task to a queue for the assigned processor, where it will wait until the processor has a sufficient amount of &quot;occupancy&quot; for the task. Once the processor is ready for the task, it will first fetch all of the task&#39;s arguments from other workers, and then it will execute the task, package the task&#39;s result into a <code>Chunk</code>, and pass that back to the core scheduler.</p><h2 id="Core:-Basics"><a class="docs-heading-anchor" href="#Core:-Basics">Core: Basics</a><a id="Core:-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Core:-Basics" title="Permalink"></a></h2><p>The core scheduler contains a single internal instance of type <code>ComputeState</code>, which maintains (among many other things) all necessary state to represent the set of waiting, ready, and running tasks, cached task results, and maps of interdependencies between tasks. It uses Julia&#39;s task infrastructure to asynchronously send work requests to remote Julia processes, and uses a <code>RemoteChannel</code> as an inbound queue for completed work.</p><p>There is an outer loop which drives the scheduler, which continues executing either eternally (excepting any internal scheduler errors or Julia exiting), or until all tasks in the graph have completed executing and the final task in the graph is ready to be returned to the user. This outer loop continuously performs two main operations: the first is to launch the execution of nodes which have become &quot;ready&quot; to execute; the second is to &quot;finish&quot; nodes which have been completed.</p><h2 id="Core:-Initialization"><a class="docs-heading-anchor" href="#Core:-Initialization">Core: Initialization</a><a id="Core:-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Core:-Initialization" title="Permalink"></a></h2><p>At the very beginning of a scheduler&#39;s lifecycle, a <code>ComputeState</code> object is allocated, workers are asynchronously initialized, and the outer loop is started. Additionally, the scheduler is passed one or more tasks to start scheduling, and so it will also fill out the <code>ComputeState</code> with the computed sets of dependencies between tasks, initially placing all tasks are placed in the &quot;waiting&quot; state. If any of the tasks are found to only have non-task input arguments, then they are considered ready to execute and moved from the &quot;waiting&quot; state to &quot;ready&quot;.</p><h2 id="Core:-Outer-Loop"><a class="docs-heading-anchor" href="#Core:-Outer-Loop">Core: Outer Loop</a><a id="Core:-Outer-Loop-1"></a><a class="docs-heading-anchor-permalink" href="#Core:-Outer-Loop" title="Permalink"></a></h2><p>At each outer loop iteration, all tasks in the &quot;ready&quot; state will be scheduled, moved into the &quot;running&quot; state, and asynchronously sent to the workers for execution (called &quot;firing&quot;). Once all tasks are either waiting or running, the scheduler may sleep until actions need to be performed</p><p>When fired tasks have completed executing, an entry will exist in the inbound queue signaling the task&#39;s result and other metadata. At this point, the most recently-queued task is removed from the queue, &quot;finished&quot;, and placed in the &quot;finished&quot; state. Finishing usually unlocks downstream tasks from the waiting state and allows them to transition to the ready state.</p><h2 id="Core:-Task-Scheduling"><a class="docs-heading-anchor" href="#Core:-Task-Scheduling">Core: Task Scheduling</a><a id="Core:-Task-Scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Core:-Task-Scheduling" title="Permalink"></a></h2><p>Once one or more tasks are ready to be scheduled, the scheduler will begin assigning them to the processors within each available worker. This is a sequential operation consisting of:</p><ul><li>Selecting candidate processors based on the task&#39;s combined scope</li><li>Calculating the cost to move needed data to each candidate processor</li><li>Adding a &quot;wait time&quot; cost proportional to the estimated run time for all the tasks currently executing on each candidate processor</li><li>Selecting the least costly candidate processor as the executor for this task</li></ul><p>After these operations have been performed for each task, the tasks will be fired off to their appropriate worker for handling.</p><h2 id="Worker:-Task-Execution"><a class="docs-heading-anchor" href="#Worker:-Task-Execution">Worker: Task Execution</a><a id="Worker:-Task-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Worker:-Task-Execution" title="Permalink"></a></h2><p>Once a worker receives one or more tasks to be executed, the tasks are immediately enqueued into the appropriate processor&#39;s queue, and the processors are notified that work is available to be executed. The processors will asynchronously look at their queues and pick the task with the lowest occupancy first; a task with zero occupancy will always be executed immediately, but most tasks have non-zero occupancy, and so will be executed in order of increasing occupancy (effectively prioritizing asynchronous tasks like I/O).</p><p>Before a task begins executions, the processor will collect the task&#39;s arguments from other workers as needed, and convert them as needed to execute correctly according to the processor&#39;s semantics. This operation is called a &quot;move&quot;.</p><p>Once a task&#39;s arguments have been moved, the task&#39;s function will be called with the arguments, and assuming the task doesn&#39;t throw an error, the result will be wrapped in a <code>Chunk</code> object. This <code>Chunk</code> will then be sent back to the core scheduler along with information about which task generated it. If the task does throw an error, then the error is instead propagated to the core scheduler, along with a flag indicating that the task failed.</p><h2 id="Worker:-Workload-Balancing"><a class="docs-heading-anchor" href="#Worker:-Workload-Balancing">Worker: Workload Balancing</a><a id="Worker:-Workload-Balancing-1"></a><a class="docs-heading-anchor-permalink" href="#Worker:-Workload-Balancing" title="Permalink"></a></h2><p>In general, Dagger&#39;s core scheduler tries to balance workloads as much as possible across all the available processors, but it can fail to do so effectively when either its cached knowledge of each worker&#39;s status is outdated, or when its estimates about the task&#39;s behavior are inaccurate. To minimize the possibility of workload imbalance, the worker schedulers&#39; processors will attempt to steal tasks from each other when they are under-occupied. Tasks will only be stolen if the task&#39;s <a href="../scopes/">scope</a> is compatibl with the processor attempting the steal, so tasks with wider scopes have better balancing potential.</p><h2 id="Core:-Finishing"><a class="docs-heading-anchor" href="#Core:-Finishing">Core: Finishing</a><a id="Core:-Finishing-1"></a><a class="docs-heading-anchor-permalink" href="#Core:-Finishing" title="Permalink"></a></h2><p>Finishing a task which has completed executing is generally a simple set of operations:</p><ul><li>The task&#39;s result is registered in the <code>ComputeState</code> for any tasks or user code which will need it</li><li>Any unneeded data is cleared from the scheduler (such as preserved <code>Chunk</code> arguments)</li><li>Downstream dependencies will be moved from &quot;waiting&quot; to &quot;ready&quot; if this task was the last upstream dependency to them</li></ul><h2 id="Core:-Shutdown"><a class="docs-heading-anchor" href="#Core:-Shutdown">Core: Shutdown</a><a id="Core:-Shutdown-1"></a><a class="docs-heading-anchor-permalink" href="#Core:-Shutdown" title="Permalink"></a></h2><p>If the core scheduler needs to shutdown due to an error or Julia exiting, then all workers will be shutdown, and the scheduler will close any open channels. If shutdown was due to an error, then an error will be printed or thrown back to the caller.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dynamic/">« Dynamic Scheduler Control</a><a class="docs-footer-nextpage" href="../api-dagger/types/">Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 24 July 2023 15:54">Monday 24 July 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
