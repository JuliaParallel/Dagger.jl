<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scheduler Internals · Dagger.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/scheduler-internals/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dagger.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../dtable/">Distributed Table</a></li><li><a class="tocitem" href="../processors/">Processors</a></li><li><a class="tocitem" href="../scopes/">Scopes</a></li><li><a class="tocitem" href="../mutation/">Mutation and Shards</a></li><li><a class="tocitem" href="../dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="../propagation/">Option Propagation</a></li><li><a class="tocitem" href="../logging/">Logging and Graphing</a></li><li><a class="tocitem" href="../scheduler-visualization/">Scheduler Visualization</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/types/">Types</a></li><li><a class="tocitem" href="../api/functions/">Functions and Macros</a></li></ul></li><li class="is-active"><a class="tocitem" href>Scheduler Internals</a><ul class="internal"><li><a class="tocitem" href="#Scheduler-Initialization"><span>Scheduler Initialization</span></a></li><li><a class="tocitem" href="#Scheduler-Outer-Loop"><span>Scheduler Outer Loop</span></a></li><li><a class="tocitem" href="#Node-Execution"><span>Node Execution</span></a></li><li><a class="tocitem" href="#Node-Finishing"><span>Node Finishing</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Scheduler Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Scheduler Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/scheduler-internals.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Scheduler-Internals"><a class="docs-heading-anchor" href="#Scheduler-Internals">Scheduler Internals</a><a id="Scheduler-Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduler-Internals" title="Permalink"></a></h1><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>This information is outdated, and until Dagger&#39;s internal scheduling APIs stabilize, it may become less and less accurate. Always read the source to understand what actually happens in Sch!</p></div></div><p>The scheduler is called <code>Dagger.Sch</code>. It contains a single internal instance of type <code>ComputeState</code>, which maintains all necessary state to represent the set of waiting, ready, and completed (or &quot;finished&quot;) graph nodes, cached <code>Chunk</code>s, and maps of interdependencies between nodes. It uses Julia&#39;s task infrastructure to asynchronously send work requests to remote compute processes, and uses a Julia <code>Channel</code> as an inbound queue for completed work. There is an outer loop which drives the scheduler, which continues executing until all nodes in the graph have completed executing and the final result of the graph is ready to be returned to the user. This outer loop continuously performs two main operations: the first is to launch the execution of nodes which have become &quot;ready&quot; to execute; the second is to &quot;finish&quot; nodes which have been completed.</p><h2 id="Scheduler-Initialization"><a class="docs-heading-anchor" href="#Scheduler-Initialization">Scheduler Initialization</a><a id="Scheduler-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduler-Initialization" title="Permalink"></a></h2><p>At the very beginning of a scheduler&#39;s lifecycle, the <code>ComputeState</code> is elaborated based on the computed sets of dependencies between nodes, and all nodes are placed in a &quot;waiting&quot; state. If any of the nodes are found to only have inputs which are not <code>Thunk</code>s, then they are moved from &quot;waiting&quot; to &quot;ready&quot;. The set of available &quot;workers&quot; (the set of available compute processes located throughout the cluster) is recorded, of size <code>Nworkers</code>.</p><h2 id="Scheduler-Outer-Loop"><a class="docs-heading-anchor" href="#Scheduler-Outer-Loop">Scheduler Outer Loop</a><a id="Scheduler-Outer-Loop-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduler-Outer-Loop" title="Permalink"></a></h2><p>At each outer loop iteration, up to <code>Nworkers</code> processes that are currently in the &quot;ready&quot; state will be moved into the &quot;running&quot; state, and asynchronously sent (along with input arguments) to one of the <code>Nworkers</code> processes for execution. Subsequently, if any nodes exist in the inbound queue (i.e. the nodes have completed execution and their result is stored on the process that executed the node), then the most recently-queued node is removed from the queue, &quot;finished&quot;, and placed in the &quot;finished&quot; state.</p><h2 id="Node-Execution"><a class="docs-heading-anchor" href="#Node-Execution">Node Execution</a><a id="Node-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Node-Execution" title="Permalink"></a></h2><p>Executing a node (here called <code>Ne</code>) in the &quot;ready&quot; state comprises two tasks. The first task is to identify which node in the set of &quot;ready&quot; nodes will be <code>Ne</code> (the node to execute). This choice is based on a concept known as &quot;affinity&quot;, which is a cost-based metric used to evaluate the suitability of executing a given node on a given process. The metric is based primarily on the location of the input arguments to the node, as well as the arguments computed size in bytes. A fixed amount of affinity is added for each argument when the process in question houses that argument. Affinity is then added based on some base affinity value multiplied by the argument&#39;s size in bytes. The total affinities for each node are then used to pick the most optimal node to execute (typically, the one with the highest affinity).</p><p>The second task is to prepare and send the node to a process for execution. If the node has been executed in the past (due to it being an argument to multiple other nodes), then the node is finished, and its result is pulled from the cache. If the node has not yet been executed, it is first checked if it is a &quot;meta&quot; node. A &quot;meta&quot; node is explicitly designated as such by the user or library, and will execute directly on its inputs as chunks (the data contained in the chunks are not immediately retrieved from the processors they reside on). Such a node will be executed directly within the scheduler, under the assumption that such a node is not expensive to execute. If the node is not a &quot;meta&quot; node, the executing worker process chooses (in round-robin fashion) a suitable processor to execute to execute the node on, based on the node&#39;s function, the input argument types, and user-defined rules for processor selection. The input arguments are then asynchronously transferred (via processor move operation) to the selected processor, and the appropriate call to the processor is made with the function and input arguments. Once execution completes and a result is obtained, it is wrapped as a <code>Chunk</code>, and the <code>Chunk</code>&#39;s handle is returned to the scheduler&#39;s inbound queue for node finishing.</p><h2 id="Node-Finishing"><a class="docs-heading-anchor" href="#Node-Finishing">Node Finishing</a><a id="Node-Finishing-1"></a><a class="docs-heading-anchor-permalink" href="#Node-Finishing" title="Permalink"></a></h2><p>&quot;Finishing&quot; a node (here called <code>Nf</code>) performs three main tasks. The first task is to find all of the downstream &quot;children&quot; nodes of <code>Nf</code> (the set of nodes which use <code>Nf</code>&#39;s result as one of their input arguments) that have had all of their input arguments computed and are in the &quot;waiting&quot; state, and move them into the &quot;ready&quot; state. The second task is to check all of the inputs to <code>Nf</code> to determine if any of them no longer have children nodes which have not been finished; if such inputs match this pattern, their cached result may be freed by the scheduler to minimize data usage. The third task is to mark <code>Nf</code> as &quot;finished&quot;, and also to indicate to the scheduler whether another node has become &quot;ready&quot; to execute.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/functions/">« Functions and Macros</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Monday 18 April 2022 18:43">Monday 18 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
