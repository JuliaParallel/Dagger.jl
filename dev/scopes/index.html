<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Scopes · Dagger.jl</title><meta name="title" content="Scopes · Dagger.jl"/><meta property="og:title" content="Scopes · Dagger.jl"/><meta property="twitter:title" content="Scopes · Dagger.jl"/><meta name="description" content="Documentation for Dagger.jl."/><meta property="og:description" content="Documentation for Dagger.jl."/><meta property="twitter:description" content="Documentation for Dagger.jl."/><meta property="og:url" content="https://JuliaParallel.github.io/Dagger.jl/scopes/"/><meta property="twitter:url" content="https://JuliaParallel.github.io/Dagger.jl/scopes/"/><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/scopes/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Dagger.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dagger.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Use Cases</span><ul><li><a class="tocitem" href="../use-cases/parallel-nested-loops/">Parallel Nested Loops</a></li></ul></li><li><a class="tocitem" href="../task-spawning/">Task Spawning</a></li><li><a class="tocitem" href="../data-management/">Data Management</a></li><li><a class="tocitem" href="../darray/">Distributed Arrays</a></li><li class="is-active"><a class="tocitem" href>Scopes</a><ul class="internal"><li><a class="tocitem" href="#Scope-Basics"><span>Scope Basics</span></a></li><li><a class="tocitem" href="#Union-Scopes"><span>Union Scopes</span></a></li><li><a class="tocitem" href="#Mismatched-Scopes"><span>Mismatched Scopes</span></a></li></ul></li><li><a class="tocitem" href="../processors/">Processors</a></li><li><a class="tocitem" href="../task-queues/">Task Queues</a></li><li><a class="tocitem" href="../datadeps/">Datadeps</a></li><li><a class="tocitem" href="../propagation/">Option Propagation</a></li><li><span class="tocitem">Logging and Visualization</span><ul><li><a class="tocitem" href="../logging/">Logging: Basics</a></li><li><a class="tocitem" href="../logging-visualization/">Logging: Visualization</a></li><li><a class="tocitem" href="../logging-advanced/">Logging: Advanced</a></li></ul></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="../scheduler-internals/">Scheduler Internals</a></li><li><span class="tocitem">Dagger API</span><ul><li><a class="tocitem" href="../api-dagger/types/">Types</a></li><li><a class="tocitem" href="../api-dagger/functions/">Functions and Macros</a></li></ul></li><li><span class="tocitem">TimespanLogging API</span><ul><li><a class="tocitem" href="../api-timespanlogging/types/">Types</a></li><li><a class="tocitem" href="../api-timespanlogging/functions/">Functions and Macros</a></li></ul></li><li><span class="tocitem">DaggerWebDash API</span><ul><li><a class="tocitem" href="../api-daggerwebdash/types/">Types</a></li><li><a class="tocitem" href="../api-daggerwebdash/functions/">Functions and Macros</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Scopes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Scopes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaParallel/Dagger.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/scopes.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Scopes"><a class="docs-heading-anchor" href="#Scopes">Scopes</a><a id="Scopes-1"></a><a class="docs-heading-anchor-permalink" href="#Scopes" title="Permalink"></a></h1><p>Sometimes you will have data that is only meaningful in a certain location, such as within a single Julia process, a given server, or even for a specific Dagger processor. We call this location a &quot;scope&quot; in Dagger, denoting the bounds within which the data is meaningful and valid. For example, C pointers are typically scoped to a process, file paths are scoped to one or more servers dependent on filesystem configuration, etc. By default, Dagger doesn&#39;t recognize this; it treats everything passed into a task, or generated from a task, as inherently safe to transfer anywhere else. When this is not the case, Dagger provides optional scopes to instruct the scheduler where data is considered valid.</p><h2 id="Scope-Basics"><a class="docs-heading-anchor" href="#Scope-Basics">Scope Basics</a><a id="Scope-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Scope-Basics" title="Permalink"></a></h2><p>Let&#39;s take the example of a webcam handle generated by VideoIO.jl. This handle is a C pointer, and thus has process scope. We can open the handle on a given process, and set the scope of the resulting data to be locked to the current process with <code>Dagger.scope</code> to construct a <code>ProcessScope</code>:</p><pre><code class="language-julia hljs">using VideoIO, Distributed

function get_handle()
    handle = VideoIO.opencamera()
    proc = Dagger.task_processor()
    scope = Dagger.scope(worker=myid()) # constructs a `ProcessScope`
    return Dagger.tochunk(handle, proc, scope)
end

cam_handle = Dagger.@spawn get_handle()</code></pre><p>Now, wherever <code>cam_handle</code> is passed, Dagger will ensure that any computations on the handle only happen within its defined scope. For example, we can read from the camera:</p><pre><code class="language-julia hljs">cam_frame = Dagger.@spawn read(cam_handle)</code></pre><p>The <code>cam_frame</code> task is executed within any processor on the same process that the <code>cam_handle</code> task was executed on. Of course, the resulting camera frame is <em>not</em> scoped to anywhere specific (denoted as <code>AnyScope</code>), and thus computations on it may execute anywhere.</p><p>You may also encounter situations where you want to use a callable struct (such as a closure, or a Flux.jl layer) only within a certain scope; you can specify the scope of the function pretty easily:</p><pre><code class="language-julia hljs">using Flux
m = Chain(...)
# If `m` is only safe to transfer to and execute on this process,
# we can set a `ProcessScope` on it:
result = Dagger.@spawn scope=Dagger.scope(worker=myid()) m(rand(8,8))</code></pre><p>Setting a scope on the function treats it as a regular piece of data (like the arguments to the function), so it participates in the scoping rules described in the following sections all the same.</p><p><a href="../api-dagger/functions/#Scope-Functions">Scope Functions</a></p><p>Now, let&#39;s try out some other kinds of scopes, starting with <code>NodeScope</code>. This scope encompasses the server that one or more Julia processes may be running on. Say we want to use memory mapping (mmap) to more efficiently send arrays between two tasks. We can construct the mmap&#39;d array in one task, attach a <code>NodeScope()</code> to it, and using the path of the mmap&#39;d file to communicate its location, lock downstream tasks to the same server:</p><pre><code class="language-julia hljs">using Mmap

function generate()
    path = &quot;myfile.bin&quot;
    arr = Mmap.mmap(path, Matrix{Int}, (64,64))
    fill!(arr, 1)
    Mmap.sync!(arr)
    # Note: Dagger.scope() does not yet support node scopes
    Dagger.tochunk(path, Dagger.task_processor(), NodeScope())
end

function consume(path)
    arr = Mmap.mmap(path, Matrix{Int}, (64,64))
    sum(arr)
end

a = Dagger.@spawn generate()
@assert fetch(Dagger.@spawn consume(a)) == 64*64</code></pre><p>Whatever server <code>a</code> executed on, <code>b</code> will also execute on it!</p><p>Finally, we come to the &quot;lowest&quot; scope on the scope hierarchy, the <code>ExactScope</code>. This scope specifies one exact processor as the bounding scope, and is typically useful in certain limited cases (such as data existing only on a specific GPU). We won&#39;t provide an example here, because you don&#39;t usually need to ever use this scope, but if you already understand the <code>NodeScope</code> and <code>ProcessScope</code>, the <code>ExactScope</code> should be easy to figure out.</p><h2 id="Union-Scopes"><a class="docs-heading-anchor" href="#Union-Scopes">Union Scopes</a><a id="Union-Scopes-1"></a><a class="docs-heading-anchor-permalink" href="#Union-Scopes" title="Permalink"></a></h2><p>Sometimes one simple scope isn&#39;t enough! In that case, you can use the <code>UnionScope</code> to construct the union of two or more scopes. Say, for example, you have some sensitive data on your company&#39;s servers that you want to compute summaries of, but you&#39;ll be driving the computation from your laptop, and you aren&#39;t allowed to send the data itself outside of the company&#39;s network. You could accomplish this by constructing a <code>UnionScope</code> of <code>ProcessScope</code>s of each of the non-laptop Julia processes, and use that to ensure that the data in its original form always stays within the company network:</p><pre><code class="language-julia hljs">addprocs(4) # some local processors
procs = addprocs([(&quot;server.company.com&quot;, 4)]) # some company processors

secrets_scope = UnionScope(ProcessScope.(procs))

function generate_secrets()
    secrets = open(&quot;/shared/secret_results.txt&quot;, &quot;r&quot;) do io
        String(read(io))
    end
    Dagger.tochunk(secrets, Dagger.task_processor(), secrets_scope)
end

summarize(secrets) = occursin(&quot;QA Pass&quot;, secrets)

# Generate the data on the first company process
sensitive_data = Dagger.@spawn single=first(procs) generate_secrets()

# We can safely call this, knowing that it will be executed on a company server
qa_passed = Dagger.@spawn summarize(sensitive_data)</code></pre><h2 id="Mismatched-Scopes"><a class="docs-heading-anchor" href="#Mismatched-Scopes">Mismatched Scopes</a><a id="Mismatched-Scopes-1"></a><a class="docs-heading-anchor-permalink" href="#Mismatched-Scopes" title="Permalink"></a></h2><p>You might now be thinking, &quot;What if I want to run a task on multiple pieces of data whose scopes don&#39;t match up?&quot; In such a case, Dagger will throw an error, refusing to schedule that task, since the intersection of the data scopes is an empty set (there is no feasible processor which can satisfy the scoping constraints). For example:</p><pre><code class="language-julia hljs">ps2 = ProcessScope(2)
ps3 = ProcessScope(3)

generate(scope) = Dagger.tochunk(rand(64), Dagger.task_processor(), scope)

d2 = Dagger.@spawn generate(ps2) # Run on process 2
d3 = Dagger.@spawn generate(ps3) # Run on process 3
res = Dagger.@spawn d2 * d3 # An error!</code></pre><p>Moral of the story: only use scopes when you know you really need them, and if you aren&#39;t careful to arrange everything just right, be prepared for Dagger to refuse to schedule your tasks! Scopes should only be used to ensure correctness of your programs, and are <em>not</em> intended to be used to optimize the schedule that Dagger uses for your tasks, since restricting the scope of execution for tasks will necessarily reduce the optimizations that Dagger&#39;s scheduler can perform.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../darray/">« Distributed Arrays</a><a class="docs-footer-nextpage" href="../processors/">Processors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 30 July 2024 18:44">Tuesday 30 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
