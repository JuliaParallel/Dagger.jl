<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Checkpointing · Dagger.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/checkpointing/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dagger.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../dtable/">Distributed Table</a></li><li><a class="tocitem" href="../processors/">Processors</a></li><li><a class="tocitem" href="../scopes/">Scopes</a></li><li><a class="tocitem" href="../dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="../logging/">Logging and Graphing</a></li><li><a class="tocitem" href="../scheduler-visualization/">Scheduler Visualization</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li class="is-active"><a class="tocitem" href>Checkpointing</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/types/">Types</a></li><li><a class="tocitem" href="../api/functions/">Functions and Macros</a></li></ul></li><li><a class="tocitem" href="../scheduler-internals/">Scheduler Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Checkpointing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Checkpointing</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/checkpointing.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Checkpointing"><a class="docs-heading-anchor" href="#Checkpointing">Checkpointing</a><a id="Checkpointing-1"></a><a class="docs-heading-anchor-permalink" href="#Checkpointing" title="Permalink"></a></h1><p>If at some point during a Dagger computation a thunk throws an error, or if the entire computation dies because the head node hit an OOM or other unexpected error, the entire computation is lost and needs to be started from scratch. This can be unacceptable for scheduling very large/expensive/mission-critical graphs, and for interactive development where errors are common and easily fixable.</p><p>Robust applications often support &quot;checkpointing&quot;, where intermediate results are periodically written out to persistent media, or sharded to the rest of the cluster, to allow resuming an interrupted computation from a point later than the original start. Dagger provides infrastructure to perform user-driven checkpointing of intermediate results once they&#39;re generated.</p><p>As a concrete example, imagine that you&#39;re developing a numerical algorithm, and distributing it with Dagger. The idea is to sum all the values in a very big matrix, and then get the square root of the absolute value of the sum of sums. Here is what that might look like:</p><pre><code class="language-julia hljs">X = compute(randn(Blocks(128,128), 1024, 1024))
Y = [delayed(sum)(chunk) for chunk in X.chunks]
inner(x...) = sqrt(sum(x))
Z = delayed(inner)(Y...)
z = collect(Z)</code></pre><p>Let&#39;s pretend that the above calculation of each element in <code>Y</code> takes a full day to run. If you run this, you might realize that if the final <code>sum</code> call returns a negative number, <code>sqrt</code> will throw a <code>DomainError</code> (because <code>sqrt</code> can&#39;t accept negative <code>Real</code> inputs). Of course, you forgot to add a call to <code>abs</code> before the call to <code>sqrt</code>! Now, you know how to fix this, but once you do, you&#39;ll have to spend another entire day waiting for it to finish! And maybe you fix this one bug and wait a full day for it to finish, and begin adding more very computationally-heavy code (which inevitably has bugs). Those later computations might fail, and if you&#39;re running this as a script (maybe under a cluster scheduler like Slurm), you have to restart everything from the very beginning. This is starting to sound pretty wasteful...</p><p>Thankfully, Dagger has a simple solution to this: checkpointing. With checkpointing, Dagger can be instructed to save intermediate results (maybe the results of computing <code>Y</code>) to a persistent storage medium of your choice. Probably a file on disk, but maybe a database, or even just stored in RAM in a space-efficient form. You also tell Dagger how to restore this data: how to take the result stored in its persistent form, and turn it back into something identical to the original intermediate data that Dagger computed. Then, when the worst happens and a piece of your algorithm throws an error (as above), Dagger will call the restore function and try to materialize those intermediate results that you painstakingly computed, so that you don&#39;t need to re-compute them.</p><p>Let&#39;s see how we&#39;d modify the above example to use checkpointing:</p><pre><code class="language-julia hljs">using Serialization
X = compute(randn(Blocks(128,128), 1024, 1024))
Y = [delayed(sum; options=Dagger.Sch.ThunkOptions(;
checkpoint=(thunk,result)-&gt;begin
    open(&quot;checkpoint-$idx.bin&quot;, &quot;w&quot;) do io
        serialize(io, collect(result))
    end
end, restore=(thunk)-&gt;begin
    open(&quot;checkpoint-$idx.bin&quot;, &quot;r&quot;) do io
        Dagger.tochunk(deserialize(io))
    end
end))(chunk) for (idx,chunk) in enumerate(X.chunks)]
inner(x...) = sqrt(sum(x))
Z = delayed(inner)(Y...)
z = collect(Z)</code></pre><p>Two changes were made: first, we <code>enumerate(X.chunks)</code> so that we can get a unique index to identify each <code>chunk</code>; second, we specify a <code>ThunkOptions</code> to <code>delayed</code> with a <code>checkpoint</code> and <code>restore</code> function that is specialized to write or read the given chunk to or from a file on disk, respectively. Notice the usage of <code>collect</code> in the <code>checkpoint</code> function, and the use of <code>Dagger.tochunk</code> in the restore function; Dagger represents intermediate results as <code>Dagger.Chunk</code> objects, so we need to convert between <code>Chunk</code>s and the actual data to keep Dagger happy. Performance-sensitive users might consider modifying these methods to store the checkpoint files on the filesystem of the server that currently owns the <code>Chunk</code>, to minimize data transfer times during checkpoint and restore operations.</p><p>If we run the above code once, we&#39;ll still end up waiting a day for <code>Y</code> to be computed, and we&#39;ll still get the <code>DomainError</code> from <code>sqrt</code>. However, when we fix the <code>inner</code> function to include that call to <code>abs</code> that was missing, and we re-run this code starting from the creation of <code>Y</code>, we&#39;ll find that we don&#39;t actually spend a day waiting; we probably spend a few seconds waiting, and end up with our final result! This is because Dagger called the <code>restore</code> function for each element of <code>Y</code>, and was provided a result by the user-specified function, so it skipped re-computing those sums entirely.</p><p>You might also notice that when you ran this code the first time, you received errors about &quot;No such file or directory&quot;, or some similar error; this occurs because Dagger <em>always</em> calls the restore function when it exists. In the first run, the checkpoint files don&#39;t yet exist, so there&#39;s nothing to restore; Dagger reports the thrown error, but keeps moving along, merrily computing the sums of <code>Y</code>. You&#39;re welcome to explicitly check if the file exists, and if not, return <code>nothing</code>; then Dagger won&#39;t report an annoying error, and will skip the restoration quietly.</p><p>Of course, you might have a lot of code that looks like this, and may want to also checkpoint the final result of the <code>z = collect(...)</code> call as well. This is just as easy to do:</p><pre><code class="language-julia hljs"># compute X, Y, Z above ...
z = collect(Z; options=Dagger.Sch.SchedulerOptions(;
checkpoint=(result)-&gt;begin
    open(&quot;checkpoint-final.bin&quot;, &quot;w&quot;) do io
        serialize(io, collect(result))
    end
end, restore=()-&gt;begin
    open(&quot;checkpoint-final.bin&quot;, &quot;r&quot;) do io
        Dagger.tochunk(deserialize(io))
    end
end))</code></pre><p>In this case, the entire computation will be skipped if <code>checkpoint-final.bin</code> exists!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../benchmarking/">« Benchmarking</a><a class="docs-footer-nextpage" href="../api/types/">Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 16 November 2021 20:50">Tuesday 16 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
