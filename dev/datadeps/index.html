<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basics · Dagger.jl</title><meta name="title" content="Basics · Dagger.jl"/><meta property="og:title" content="Basics · Dagger.jl"/><meta property="twitter:title" content="Basics · Dagger.jl"/><meta name="description" content="Documentation for Dagger.jl."/><meta property="og:description" content="Documentation for Dagger.jl."/><meta property="twitter:description" content="Documentation for Dagger.jl."/><meta property="og:url" content="https://JuliaParallel.github.io/Dagger.jl/datadeps/"/><meta property="twitter:url" content="https://JuliaParallel.github.io/Dagger.jl/datadeps/"/><link rel="canonical" href="https://JuliaParallel.github.io/Dagger.jl/datadeps/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Dagger.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dagger.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Use Cases</span><ul><li><a class="tocitem" href="../use-cases/parallel-nested-loops/">Parallel Nested Loops</a></li></ul></li><li><a class="tocitem" href="../task-spawning/">Task Spawning</a></li><li><a class="tocitem" href="../task-affinity/">Task Affinity</a></li><li><a class="tocitem" href="../data-management/">Data Management</a></li><li><a class="tocitem" href="../darray/">Distributed Arrays</a></li><li><a class="tocitem" href="../streaming/">Streaming Tasks</a></li><li><a class="tocitem" href="../scopes/">Scopes</a></li><li><a class="tocitem" href="../processors/">Processors</a></li><li><a class="tocitem" href="../task-queues/">Task Queues</a></li><li><span class="tocitem">Datadeps</span><ul><li class="is-active"><a class="tocitem" href>Basics</a><ul class="internal"><li><a class="tocitem" href="#Limitations"><span>Limitations</span></a></li><li><a class="tocitem" href="#Aliasing-Support"><span>Aliasing Support</span></a></li><li><a class="tocitem" href="#In-place-data-movement-rules"><span>In-place data movement rules</span></a></li><li><a class="tocitem" href="#Chunk-and-DTask-slicing-with-view"><span>Chunk and DTask slicing with <code>view</code></span></a></li></ul></li><li><a class="tocitem" href="../stencils/">Stencils</a></li></ul></li><li><a class="tocitem" href="../gpu/">GPUs</a></li><li><a class="tocitem" href="../propagation/">Option Propagation</a></li><li><span class="tocitem">Logging and Visualization</span><ul><li><a class="tocitem" href="../logging/">Logging: Basics</a></li><li><a class="tocitem" href="../logging-visualization/">Logging: Visualization</a></li><li><a class="tocitem" href="../logging-advanced/">Logging: Advanced</a></li></ul></li><li><span class="tocitem">External Languages</span><ul><li><a class="tocitem" href="../external-languages/python/">Python</a></li></ul></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking</a></li><li><a class="tocitem" href="../dynamic/">Dynamic Scheduler Control</a></li><li><a class="tocitem" href="../scheduler-internals/">Scheduler Internals</a></li><li><span class="tocitem">Dagger API</span><ul><li><a class="tocitem" href="../api-dagger/types/">Types</a></li><li><a class="tocitem" href="../api-dagger/functions/">Functions and Macros</a></li></ul></li><li><span class="tocitem">TimespanLogging API</span><ul><li><a class="tocitem" href="../api-timespanlogging/types/">Types</a></li><li><a class="tocitem" href="../api-timespanlogging/functions/">Functions and Macros</a></li></ul></li><li><span class="tocitem">DaggerWebDash API</span><ul><li><a class="tocitem" href="../api-daggerwebdash/types/">Types</a></li><li><a class="tocitem" href="../api-daggerwebdash/functions/">Functions and Macros</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Datadeps</a></li><li class="is-active"><a href>Basics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaParallel/Dagger.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaParallel/Dagger.jl/blob/master/docs/src/datadeps.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Datadeps-(Data-Dependencies)"><a class="docs-heading-anchor" href="#Datadeps-(Data-Dependencies)">Datadeps (Data Dependencies)</a><a id="Datadeps-(Data-Dependencies)-1"></a><a class="docs-heading-anchor-permalink" href="#Datadeps-(Data-Dependencies)" title="Permalink"></a></h1><p>For many programs, the restriction that tasks cannot write to their arguments feels overly restrictive and makes certain kinds of programs (such as in-place linear algebra) hard to express efficiently in Dagger. Thankfully, there is a solution called &quot;Datadeps&quot; (short for &quot;data dependencies&quot;), accessible through the <code>spawn_datadeps</code> function. This function constructs a &quot;datadeps region&quot;, within which tasks are allowed to write to their arguments, with parallelism controlled via dependencies specified via argument annotations. At the end of the &quot;datadeps region&quot; the <code>spawn_datadeps</code> will wait for the completion of all the tasks launched within it. Let&#39;s look at a simple example to make things concrete:</p><pre><code class="language-julia hljs">A = rand(1000)
B = rand(1000)
C = zeros(1000)
@everywhere add!(X, Y) = X .+= Y
Dagger.spawn_datadeps() do
    Dagger.@spawn add!(InOut(B), In(A))
    Dagger.@spawn copyto!(Out(C), In(B))
end</code></pre><p>In this example, we have two Dagger tasks being launched, one adding <code>A</code> into <code>B</code>, and the other copying <code>B</code> into <code>C</code>. The <code>add!</code> task is specifying that <code>A</code> is being only read from (<code>In</code> for &quot;input&quot;), and that <code>B</code> is being read from and written to (<code>Out</code> for &quot;output&quot;, <code>InOut</code> for &quot;input and output&quot;). The <code>copyto</code> task, similarly, is specifying that <code>B</code> is being read from, and <code>C</code> is only being written to.</p><p>Without <code>spawn_datadeps</code> and <code>In</code>, <code>Out</code>, and <code>InOut</code>, the result of these tasks would be undefined; the two tasks could execute in parallel, or the <code>copyto!</code> could occur before the <code>add!</code>, resulting in all kinds of mayhem. However, <code>spawn_datadeps</code> changes things: because we have told Dagger how our tasks access their arguments, Dagger knows to control the parallelism and ordering, and ensure that <code>add!</code> executes and finishes before <code>copyto!</code> begins, ensuring that <code>copyto!</code> &quot;sees&quot; the changes to <code>B</code> before executing.</p><p>There is another important aspect of <code>spawn_datadeps</code> that makes the above code work: if all of the <code>Dagger.@spawn</code> macros are removed, along with the dependency specifiers, the program would still produce the same results, without using Dagger. In other words, the parallel (Dagger) version of the program produces identical results to the serial (non-Dagger) version of the program. This is similar to using Dagger with purely functional tasks and without <code>spawn_datadeps</code> - removing <code>Dagger.@spawn</code> will still result in a correct (sequential and possibly slower) version of the program. Basically, <code>spawn_datadeps</code> will ensure that Dagger respects the ordering and dependencies of a program, while still providing parallelism, where possible.</p><p>But where is the parallelism? The above example doesn&#39;t actually have any parallelism to exploit! Let&#39;s take a look at another example to see the datadeps model truly shine:</p><pre><code class="language-julia hljs"># Tree reduction of multiple arrays into the first array
function tree_reduce!(op::Base.Callable, As::Vector{&lt;:Array})
    Dagger.spawn_datadeps() do
        to_reduce = Vector[]
        push!(to_reduce, As)
        while !isempty(to_reduce)
            As = pop!(to_reduce)
            n = length(As)
            if n == 2
                Dagger.@spawn Base.mapreducedim!(identity, op, InOut(As[1]), In(As[2]))
            elseif n &gt; 2
                push!(to_reduce, [As[1], As[div(n,2)+1]])
                push!(to_reduce, As[1:div(n,2)])
                push!(to_reduce, As[div(n,2)+1:end])
            end
        end
    end
    return As[1]
end

As = [rand(1000) for _ in 1:1000]
Bs = copy.(As)
tree_reduce!(+, As)
@assert isapprox(As[1], reduce((x,y)-&gt;x .+ y, Bs))</code></pre><p>In the above implementation of <code>tree_reduce!</code> (which is designed to perform an elementwise reduction across a vector of arrays), we have a tree reduction operation where pairs of arrays are reduced, starting with neighboring pairs, and then reducing pairs of reduction results, etc. until the final result is in <code>As[1]</code>. We can see that the application of Dagger to this algorithm is simple - only the single <code>Base.mapreducedim!</code> call is passed to Dagger - yet due to the data dependencies and the algorithm&#39;s structure, there should be plenty of parallelism to be exploited across each of the parallel reductions at each &quot;level&quot; of the reduction tree. Specifically, any two <code>Dagger.@spawn</code> calls which access completely different pairs of arrays can execute in parallel, while any call which has an <code>In</code> on an array will wait for any previous call which has an <code>InOut</code> on that same array.</p><p>Additionally, we can notice a powerful feature of this model - if the <code>Dagger.@spawn</code> macro is removed, the code still remains correct, but simply runs sequentially. This means that the structure of the program doesn&#39;t have to change in order to use Dagger for parallelization, which can make applying Dagger to existing algorithms quite effortless.</p><h2 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h2><p>It&#39;s important to be aware of a key limitation when working with <code>Dagger.spawn_datadeps</code>. Operations that involve explicit synchronization or fetching results of other Dagger tasks, such as <code>fetch</code>, <code>wait</code>, or <code>@sync</code>, cannot be used directly inside a <code>spawn_datadeps</code> block.</p><p>The <code>spawn_datadeps</code> region is designed to manage data dependencies automatically based on the <code>In</code>, <code>Out</code>, and <code>InOut</code> annotations. Introducing explicit synchronization primitives can interfere with this mechanism and lead to unexpected behavior or errors.</p><p><strong>Example of what NOT to do:</strong></p><pre><code class="language-julia hljs">Dagger.spawn_datadeps() do
    # Incorrect: Using fetch inside spawn_datadeps
    task1 = Dagger.@spawn my_func1!(InOut(A))
    result1 = fetch(task1) # This will not work as expected

    # Incorrect: Using wait inside spawn_datadeps
    task2 = Dagger.@spawn my_func2!(InOut(B))
    wait(task2) # This will also lead to issues

    # Incorrect: Using @sync inside spawn_datadeps
    @sync begin
        Dagger.@spawn my_func3!(InOut(C))
        Dagger.@spawn my_func4!(InOut(D))
    end
end</code></pre><p>If you need to synchronize or fetch results, these operations should be performed outside the <code>spawn_datadeps</code> block. The primary purpose of <code>spawn_datadeps</code> is to define a region where data dependencies for mutable operations are automatically managed.</p><h2 id="Aliasing-Support"><a class="docs-heading-anchor" href="#Aliasing-Support">Aliasing Support</a><a id="Aliasing-Support-1"></a><a class="docs-heading-anchor-permalink" href="#Aliasing-Support" title="Permalink"></a></h2><p>Datadeps is smart enough to detect when two arguments from different tasks actually access the same memory (we say that these arguments &quot;alias&quot;). There&#39;s the obvious case where the two arguments are exactly the same object, but Datadeps is also aware of more subtle cases, such as when two arguments are different views into the same array, or where two arrays point to the same underlying memory. In these cases, Datadeps will ensure that the tasks are executed in the correct order - if one task writes to an argument which aliases with an argument read by another task, those two tasks will be executed in sequence, rather than in parallel.</p><p>There are two ways to specify aliasing to Datadeps. The simplest way is the most straightforward: if the argument passed to a task is a view or another supported object (such as an <code>UpperTriangular</code>-wrapped array), Datadeps will compare it with all other task&#39;s arguments to determine if they alias. This works great when you want to pass that view or <code>UpperTriangular</code> object directly to the called function. For example:</p><pre><code class="language-julia hljs">A = rand(1000)
A_l = view(A, 1:500)
A_r = view(A, 501:1000)

# inc! supports views, so we can pass A_l and A_r directly
@everywhere inc!(X) = X .+= 1

Dagger.spawn_datadeps() do
    # These two tasks don&#39;t alias, so they can run in parallel
    Dagger.@spawn inc!(InOut(A_l))
    Dagger.@spawn inc!(InOut(A_r))

    # This task aliases with the previous two, so it will run after them
    Dagger.@spawn inc!(InOut(A))
end</code></pre><p>The other way allows you to separate what argument is passed to the function, from how that argument is accessed within the function. This is done with the <code>Deps</code> wrapper, which is used like so:</p><pre><code class="language-julia hljs">A = rand(1000, 1000)

@everywhere inc_upper!(X) = UpperTriangular(X) .+= 1
@everywhere inc_ulower!(X) = UnitLowerTriangular(X) .+= 1
@everywhere inc_diag!(X) = X[diagind(X)] .+= 1

Dagger.spawn_datadeps() do
    # These two tasks don&#39;t alias, so they can run in parallel
    Dagger.@spawn inc_upper!(Deps(A, InOut(UpperTriangular)))
    Dagger.@spawn inc_ulower!(Deps(A, InOut(UnitLowerTriangular)))

    # This task aliases with the `inc_upper!` task (`UpperTriangular` accesses the diagonal of the array)
    Dagger.@spawn inc_diag!(Deps(A, InOut(Diagonal)))
end</code></pre><p>We call <code>InOut(Diagonal)</code> an &quot;aliasing modifier&quot;. The purpose of <code>Deps</code> is to pass an argument (here, <code>A</code>) as-is, while specifying to Datadeps what portions of the argument will be accessed (in this case, the diagonal elements) and how (read/write/both). You can pass any number of aliasing modifiers to <code>Deps</code>.</p><p><code>Deps</code> is particularly useful for declaring aliasing with <code>Diagonal</code>, <code>Bidiagonal</code>, <code>Tridiagonal</code>, and <code>SymTridiagonal</code> access, as these &quot;wrappers&quot; make a copy of their parent array and thus can&#39;t be used to &quot;mask&quot; access to the parent like <code>UpperTriangular</code> and <code>UnitLowerTriangular</code> can (which is valuable for writing memory-efficient, generic algorithms in Julia).</p><h3 id="Supported-Aliasing-Modifiers"><a class="docs-heading-anchor" href="#Supported-Aliasing-Modifiers">Supported Aliasing Modifiers</a><a id="Supported-Aliasing-Modifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-Aliasing-Modifiers" title="Permalink"></a></h3><ul><li>Any function that returns the original object or a view of the original object</li><li><code>UpperTriangular</code>/<code>LowerTriangular</code>/<code>UnitUpperTriangular</code>/<code>UnitLowerTriangular</code></li><li><code>Diagonal</code>/<code>Bidiagonal</code>/<code>Tridiagonal</code>/<code>SymTridiagonal</code> (via <code>Deps</code>, e.g. to read from the diagonal of <code>X</code>: <code>Dagger.@spawn sum(Deps(X, In(Diagonal)))</code>)</li><li><code>Symbol</code> for field access (via <code>Deps</code>, e.g. to write to <code>X.value</code>: <code>Dagger.@spawn setindex!(Deps(X, InOut(:value)), :value, 42)</code></li></ul><h2 id="In-place-data-movement-rules"><a class="docs-heading-anchor" href="#In-place-data-movement-rules">In-place data movement rules</a><a id="In-place-data-movement-rules-1"></a><a class="docs-heading-anchor-permalink" href="#In-place-data-movement-rules" title="Permalink"></a></h2><p>Datadeps uses a specialized 5-argument function, <code>Dagger.move!(dep_mod, from_space::Dagger.MemorySpace, to_space::Dagger.MemorySpace, from, to)</code>, for managing in-place data movement. This function is an in-place variant of the more general <code>move</code> function (see <a href="../data-management/#Data-movement-rules">Data movement rules</a>) and is exclusively used within the Datadeps system. The <code>dep_mod</code> argument is usually just <code>identity</code>, but it can also be an access modifier function like <code>UpperTriangular</code>, which limits what portion of the data should be read from and written to.</p><p>The core responsibility of <code>move!</code> is to read data from the <code>from</code> argument and write it directly into the <code>to</code> argument. This is crucial for operations that modify data in place, as often encountered in numerical computing and linear algebra.</p><p>The default implementation of <code>move!</code> handles <code>Chunk</code> objects by unwrapping them and then recursively calling <code>move!</code> on the underlying values. This ensures that the in-place operation is performed on the actual data.</p><p>Users have the option to define their own <code>move!</code> implementations for custom data types. However, this is typically not necessary for types that are subtypes of <code>AbstractArray</code>, provided that these types support the standard <code>Base.copyto!(to, from)</code> function. The default <code>move!</code> will leverage <code>copyto!</code> for such array types, enabling efficient in-place updates.</p><p>Here&#39;s an example of a custom <code>move!</code> implementation:</p><pre><code class="language-julia hljs">struct MyCustomArrayWrapper{T,N}
    data::Array{T,N}
end

# Custom move! function for MyCustomArrayWrapper
function Dagger.move!(dep_mod::Any, from_space::Dagger.MemorySpace, to_space::Dagger.MemorySpace, from::MyCustomArrayWrapper, to::MyCustomArrayWrapper)
    copyto!(dep_mod(to.data), dep_mod(from.data))
    return
end</code></pre><h2 id="Chunk-and-DTask-slicing-with-view"><a class="docs-heading-anchor" href="#Chunk-and-DTask-slicing-with-view">Chunk and DTask slicing with <code>view</code></a><a id="Chunk-and-DTask-slicing-with-view-1"></a><a class="docs-heading-anchor-permalink" href="#Chunk-and-DTask-slicing-with-view" title="Permalink"></a></h2><p>The <code>view</code> function allows you to efficiently create a &quot;view&quot; of a <code>Chunk</code> or <code>DTask</code> that contains an array. This enables operations on specific parts of your distributed data using standard Julia array slicing, without needing to materialize the entire array.</p><pre><code class="language-julia hljs">    view(c::Chunk, slices...) -&gt; ChunkView
    view(c::DTask, slices...) -&gt; ChunkView</code></pre><p>These methods create a <code>ChunkView</code> of a <code>Chunk</code> or <code>DTask</code>, which may be used as an argument to a <code>Dagger.@spawn</code> call in a Datadeps region. You specify the desired view using standard Julia array slicing syntax, identical to how you would slice a regular array.</p><h4 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h4><pre><code class="language-julia hljs">julia&gt; A = rand(64, 64)
64×64 Matrix{Float64}:
[...]

julia&gt; DA = DArray(A, Blocks(8,8)) 
64x64 DMatrix{Float64} with 8x8 partitions of size 8x8:
[...]

julia&gt; chunk = DA.chunks[1,1] 
DTask (finished)

julia&gt; view(chunk, :, :) # View the entire 8x8 chunk
ChunkSlice{2}(Dagger.Chunk(...), (Colon(), Colon()))

julia&gt; view(chunk, 1:4, 1:4) # View the top-left 4x4 sub-region of the chunk
ChunkSlice{2}(Dagger.Chunk(...), (1:4, 1:4))

julia&gt; view(chunk, 1, :) # View the first row of the chunk
ChunkSlice{2}(Dagger.Chunk(...), (1, Colon()))

julia&gt; view(chunk, :, 5) # View the fifth column of the chunk
ChunkSlice{2}(Dagger.Chunk(...), (Colon(), 5))

julia&gt; view(chunk, 1:2:7, 2:2:8) # View with stepped ranges
ChunkSlice{2}(Dagger.Chunk(...), (1:2:7, 2:2:8))</code></pre><h4 id="Example-Usage:-Parallel-Row-Summation-of-a-DArray-using-view"><a class="docs-heading-anchor" href="#Example-Usage:-Parallel-Row-Summation-of-a-DArray-using-view">Example Usage: Parallel Row Summation of a DArray using <code>view</code></a><a id="Example-Usage:-Parallel-Row-Summation-of-a-DArray-using-view-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Usage:-Parallel-Row-Summation-of-a-DArray-using-view" title="Permalink"></a></h4><p>This example demonstrates how to sum multiple rows of a <code>DArray</code> by using <code>view</code> to process individual rows within chunks to get a vector of row sums.</p><pre><code class="language-julia hljs">julia&gt; A = DArray(rand(10, 1000), Blocks(2, 1000))
10x1000 DMatrix{Float64} with 5x1 partitions of size 2x1000: 
[...]

# Helper function to sum a single row and store it in a provided array view
julia&gt; @everywhere function sum_array_row!(row_sum::AbstractArray{Float64}, x::AbstractArray{Float64})
    row_sum[1] = sum(x)
end

# Number of rows
julia&gt; nrows = size(A,1)

# Initialize a zero array in the final row sums
julia&gt; row_sums = zeros(nrows)

# Spawn tasks to sum each row in parallel using views
julia&gt; Dagger.spawn_datadeps() do
           sz = size(A.chunks,1) 
           nrows_per_chunk = nrows ÷ sz
           for i in 1:sz
               for j in 1:nrows_per_chunk
                   Dagger.@spawn sum_array_row!(Out(view(row_sums, (nrows_per_chunk*(i-1)+j):(nrows_per_chunk*(i-1)+j))),
                                                In(Dagger.view(A.chunks[i,1], j:j, :)))
               end
           end
       end

# Print the result
julia&gt; println(&quot;Row sums: &quot;, row_sums)
Row sums: [499.8765, 500.1234, ..., 499.9876]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../task-queues/">« Task Queues</a><a class="docs-footer-nextpage" href="../stencils/">Stencils »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 23 September 2025 21:57">Tuesday 23 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
