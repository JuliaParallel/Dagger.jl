### Mutation

function _mutable_inner(@nospecialize(f), proc, scope)
    result = f()
    return Ref(Dagger.tochunk(result, proc, scope))
end

"""
    mutable(f::Base.Callable; worker, processor, scope) -> Chunk

Calls `f()` on the specified worker or processor, returning a `Chunk`
referencing the result with the specified scope `scope`.
"""
function mutable(@nospecialize(f); worker=nothing, processor=nothing, scope=nothing)
    if processor === nothing
        if worker === nothing
            processor = OSProc()
        else
            processor = OSProc(worker)
        end
    else
        @assert worker === nothing "mutable: Can't mix worker and processor"
    end
    if scope === nothing
        scope = processor isa OSProc ? ProcessScope(processor) : ExactScope(processor)
    end
    return fetch(Dagger.@spawn scope=scope _mutable_inner(f, processor, scope))[]
end

"""
    @mutable [worker=1] [processor=OSProc()] [scope=ProcessorScope()] f()

Helper macro for [`mutable()`](@ref).
"""
macro mutable(exs...)
    opts = esc.(exs[1:end-1])
    ex = exs[end]
    quote
        let f = @noinline ()->$(esc(ex))
            $mutable(f; $(opts...))
        end
    end
end

"""
Maps a value to one of multiple distributed "mirror" values automatically when
used as a thunk argument. Construct using `@shard` or `shard`.
"""
struct Shard
    chunks::Dict{Processor,Chunk}
end

"""
    shard(f; kwargs...) -> Chunk{Shard}

Executes `f` on all workers in `workers`, wrapping the result in a
process-scoped `Chunk`, and constructs a `Chunk{Shard}` containing all of these
`Chunk`s on the current worker.

Keyword arguments:
- `procs` -- The list of processors to create pieces on. May be any iterable container of `Processor`s.
- `workers` -- The list of workers to create pieces on. May be any iterable container of `Integer`s.
- `per_thread::Bool=false` -- If `true`, creates a piece per each thread, rather than a piece per each worker.
"""
function shard(@nospecialize(f); procs=nothing, workers=nothing, per_thread=false)
    if procs === nothing
        if workers !== nothing
            procs = [OSProc(w) for w in workers]
        else
            procs = lock(Sch.eager_context()) do
                copy(Sch.eager_context().procs)
            end
        end
        if per_thread
            _procs = ThreadProc[]
            for p in procs
                append!(_procs, filter(p->p isa ThreadProc, get_processors(p)))
            end
            procs = _procs
        end
    else
        if workers !== nothing
            throw(ArgumentError("Cannot combine `procs` and `workers`"))
        elseif per_thread
            throw(ArgumentError("Cannot combine `procs` and `per_thread=true`"))
        end
    end
    isempty(procs) && throw(ArgumentError("Cannot create empty Shard"))
    shard_running_dict = Dict{Processor,DTask}()
    for proc in procs
        scope = proc isa OSProc ? ProcessScope(proc) : ExactScope(proc)
        thunk = Dagger.@spawn scope=scope _mutable_inner(f, proc, scope)
        shard_running_dict[proc] = thunk
    end
    shard_dict = Dict{Processor,Chunk}()
    for proc in procs
        shard_dict[proc] = fetch(shard_running_dict[proc])[]
    end
    return Shard(shard_dict)
end

"Creates a `Shard`. See [`Dagger.shard`](@ref) for details."
macro shard(exs...)
    opts = esc.(exs[1:end-1])
    ex = exs[end]
    quote
        let f = @noinline ()->$(esc(ex))
            $shard(f; $(opts...))
        end
    end
end

function move(from_proc::Processor, to_proc::Processor, shard::Shard)
    # Match either this proc or some ancestor
    # N.B. This behavior may bypass the piece's scope restriction
    proc = to_proc
    if haskey(shard.chunks, proc)
        return move(from_proc, to_proc, shard.chunks[proc])
    end
    parent = Dagger.get_parent(proc)
    while parent != proc
        proc = parent
        parent = Dagger.get_parent(proc)
        if haskey(shard.chunks, proc)
            return move(from_proc, to_proc, shard.chunks[proc])
        end
    end

    throw(KeyError(to_proc))
end
Base.iterate(s::Shard) = iterate(values(s.chunks))
Base.iterate(s::Shard, state) = iterate(values(s.chunks), state)
Base.length(s::Shard) = length(s.chunks)

### Core Stuff

"""
    tochunk(x, proc::Processor, scope::AbstractScope; device=nothing, rewrap=false, kwargs...) -> Chunk

Create a chunk from data `x` which resides on `proc` and which has scope
`scope`.

`device` specifies a `MemPool.StorageDevice` (which is itself wrapped in a
`Chunk`) which will be used to manage the reference contained in the `Chunk`
generated by this function. If `device` is `nothing` (the default), the data
will be inspected to determine if it's safe to serialize; if so, the default
MemPool storage device will be used; if not, then a `MemPool.CPURAMDevice` will
be used.

If `rewrap==true` and `x isa Chunk`, then the `Chunk` will be rewrapped in a
new `Chunk`.

All other kwargs are passed directly to `MemPool.poolset`.
"""
function tochunk(x::X, proc::P=OSProc(), scope::S=AnyScope(); cache=false, device=nothing, rewrap=false, kwargs...) where {X,P,S}
    if device === nothing
        device = if Sch.walk_storage_safe(x)
            MemPool.GLOBAL_DEVICE[]
        else
            MemPool.CPURAMDevice()
        end
    end
    ref = poolset(x; device, kwargs...)
    Chunk{X,typeof(ref),P,S}(X, domain(x), ref, proc, scope)
end
function tochunk(x::Chunk, proc=nothing, scope=nothing; rewrap=false, kwargs...)
    if rewrap
        return remotecall_fetch(x.handle.owner) do
            tochunk(MemPool.poolget(x.handle), proc, scope; kwargs...)
        end
    else
        return x
    end
end
tochunk(x::Thunk, proc=nothing, scope=nothing; kwargs...) = x

function savechunk(data, dir, f)
    sz = open(joinpath(dir, f), "w") do io
        serialize(io, MemPool.MMWrap(data))
        return position(io)
    end
    fr = FileRef(f, sz)
    proc = OSProc()
    scope = AnyScope() # FIXME: Scoped to this node
    Chunk{typeof(data),typeof(fr),typeof(proc),typeof(scope)}(typeof(data), domain(data), fr, proc, scope, true)
end
